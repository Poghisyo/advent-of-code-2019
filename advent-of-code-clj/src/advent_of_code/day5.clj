(ns advent-of-code.day5
  (:require [clojure.string :as string])
  (:gen-class))

(def input [1,12,2,3,1,1,2,3,1,3,4,3,1,5,0,3,2,1,6,19,1,9,19,23,2,23,10,27,1,27,5,31,1,31,6,35,1,6,35,39,2,39,13,43,1,9,43,47,2,9,47,51,1,51,6,55,2,55,10,59,1,59,5,63,2,10,63,67,2,9,67,71,1,71,5,75,2,10,75,79,1,79,6,83,2,10,83,87,1,5,87,91,2,9,91,95,1,95,5,99,1,99,2,103,1,103,13,0,99,2,14,0,0])

(def inp-2 [
            3,225,1,225,6,6,1100,1,238,225,104,0,1101,37,61,225,101,34,121,224,1001,224,-49,224,4,224,102,8,223,223,1001,224,6,224,1,224,223,223,1101,67,29,225,1,14,65,224,101,-124,224,224,4,224,1002,223,8,223,101,5,224,224,1,224,223,223,1102,63,20,225,1102,27,15,225,1102,18,79,224,101,-1422,224,224,4,224,102,8,223,223,1001,224,1,224,1,223,224,223,1102,20,44,225,1001,69,5,224,101,-32,224,224,4,224,1002,223,8,223,101,1,224,224,1,223,224,223,1102,15,10,225,1101,6,70,225,102,86,40,224,101,-2494,224,224,4,224,1002,223,8,223,101,6,224,224,1,223,224,223,1102,25,15,225,1101,40,67,224,1001,224,-107,224,4,224,102,8,223,223,101,1,224,224,1,223,224,223,2,126,95,224,101,-1400,224,224,4,224,1002,223,8,223,1001,224,3,224,1,223,224,223,1002,151,84,224,101,-2100,224,224,4,224,102,8,223,223,101,6,224,224,1,224,223,223,4,223,99,0,0,0,677,0,0,0,0,0,0,0,0,0,0,0,1105,0,99999,1105,227,247,1105,1,99999,1005,227,99999,1005,0,256,1105,1,99999,1106,227,99999,1106,0,265,1105,1,99999,1006,0,99999,1006,227,274,1105,1,99999,1105,1,280,1105,1,99999,1,225,225,225,1101,294,0,0,105,1,0,1105,1,99999,1106,0,300,1105,1,99999,1,225,225,225,1101,314,0,0,106,0,0,1105,1,99999,108,677,677,224,1002,223,2,223,1006,224,329,101,1,223,223,1107,677,226,224,102,2,223,223,1006,224,344,101,1,223,223,8,677,677,224,1002,223,2,223,1006,224,359,101,1,223,223,1008,677,677,224,1002,223,2,223,1006,224,374,101,1,223,223,7,226,677,224,1002,223,2,223,1006,224,389,1001,223,1,223,1007,677,677,224,1002,223,2,223,1006,224,404,1001,223,1,223,7,677,677,224,1002,223,2,223,1006,224,419,1001,223,1,223,1008,677,226,224,1002,223,2,223,1005,224,434,1001,223,1,223,1107,226,677,224,102,2,223,223,1005,224,449,1001,223,1,223,1008,226,226,224,1002,223,2,223,1006,224,464,1001,223,1,223,1108,677,677,224,102,2,223,223,1006,224,479,101,1,223,223,1108,226,677,224,1002,223,2,223,1006,224,494,1001,223,1,223,107,226,226,224,1002,223,2,223,1006,224,509,1001,223,1,223,8,226,677,224,102,2,223,223,1006,224,524,1001,223,1,223,1007,226,226,224,1002,223,2,223,1006,224,539,1001,223,1,223,107,677,677,224,1002,223,2,223,1006,224,554,1001,223,1,223,1107,226,226,224,102,2,223,223,1005,224,569,101,1,223,223,1108,677,226,224,1002,223,2,223,1006,224,584,1001,223,1,223,1007,677,226,224,1002,223,2,223,1005,224,599,101,1,223,223,107,226,677,224,102,2,223,223,1005,224,614,1001,223,1,223,108,226,226,224,1002,223,2,223,1005,224,629,101,1,223,223,7,677,226,224,102,2,223,223,1005,224,644,101,1,223,223,8,677,226,224,102,2,223,223,1006,224,659,1001,223,1,223,108,677,226,224,102,2,223,223,1005,224,674,1001,223,1,223,4,223,99,226])

(defn split-num
  [number]
  (map #(Integer. %) (string/split (str number) #"")))

(defn pad-num
  [number]
  (if (< (count number) 5)
    (concat (take (- 5 (count number)) [0 0 0 0 0]) number)
    number))

(defn read-opcode
  [opcode]
  (let [code (pad-num (split-num opcode))
        mode-3 (first code)
        mode-2 (second code)
        mode-1 (second (rest code))
        n-opcode (reduce (fn [a v] (Integer. (str a v))) [(second (rest (rest code))) (last code)])]
    [n-opcode mode-1 mode-2 mode-3]))

(defn position-value
  [input offset]
  (get input offset))

(defn address-value
  [input offset]
  (get input (get input offset)))

(defn run-intcode
  [input]
  (loop [position 0
         input input]
    (let [[opcode mode-1 mode-2 mode-3] (read-opcode (get input position))
          next-position (case opcode
                           01 (+ 4 position)
                           02 (+ 4 position)
                           03 (+ 2 position)
                           04 (+ 2 position)
                           99 (+ 2 position)
                          nil)
          end (or (= 99 opcode) (>= (+ 4 position) (count input)))
          noun (case mode-1
                 0 (address-value input (+ 1 position))
                 1 (position-value input (+ 1 position)))
          verb (case mode-2
                 0 (address-value input (+ 2 position))
                 1 (position-value input (+ 2 position)))
          target (case opcode
                   03 (position-value input (+ 1 position))
                   (position-value input (+ 3 position)))
          output (case opcode
                   01 (+ noun verb)
                   02 (* noun verb)
                   03 (do
                        (println "input '1':")
                        (Integer. (read-line)))
                   04 nil
                   99 nil
                   nil)

          result (if output
                   (reduce-kv (fn [m k v]

                               (if (and (= k target) (not (= opcode 04)))
                                 (conj m output)
                                 (conj m v)))

                           []
                           input)
                   input)]
      (if (= opcode 04)
        (do
          (println (address-value input (+ 1 position)))))
      (if end
        (first result)
        (recur next-position result)))))

(defn -main
  []
  (println "day 5: prob 1")
  (run-intcode inp-2))
